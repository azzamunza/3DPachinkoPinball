<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Neon Slot Machine</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            background-image: url('../references/heiwa-pachinko-world-64-nintendo-64-videogame-editorial-use-only-2BXTJM3.jpg');
            background-size: cover;
            background-position: center;
            font-family: 'Courier New', Courier, monospace;
            user-select: none;
        }

        /* HUD / UI Styles */
        #ui-container {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            z-index: 10;
            pointer-events: none; /* Let clicks pass through to 3D canvas */
        }

        .hud-panel {
            background: linear-gradient(to bottom, #2b2b2b, #111);
            border: 3px solid #d4af37; /* Gold border */
            border-radius: 15px;
            padding: 20px;
            display: inline-block;
            pointer-events: auto;
            box-shadow: 
                0 0 15px rgba(212, 175, 55, 0.5),
                inset 0 0 20px rgba(0,0,0,0.8);
        }

        .btn {
            background: linear-gradient(180deg, #ff4444, #990000);
            border: 2px solid #fff;
            color: white;
            padding: 15px 40px;
            font-size: 24px;
            font-weight: 900;
            border-radius: 50px;
            cursor: pointer;
            text-transform: uppercase;
            box-shadow: 0 6px 0 #660000, 0 10px 10px rgba(0,0,0,0.5);
            transition: all 0.1s;
            margin: 0 15px;
            text-shadow: 0 2px 2px rgba(0,0,0,0.5);
        }

        .btn:active {
            transform: translateY(4px);
            box-shadow: 0 2px 0 #660000, 0 2px 5px rgba(0,0,0,0.5);
        }

        .btn:disabled {
            background: #444;
            box-shadow: none;
            color: #888;
            border-color: #666;
            cursor: not-allowed;
            transform: translateY(4px);
        }

        .btn-coin {
            background: linear-gradient(180deg, #ffd700, #b8860b);
            box-shadow: 0 6px 0 #8b6508, 0 10px 10px rgba(0,0,0,0.5);
            color: #4a3c00;
            border-color: #ffeba0;
        }

        .btn-coin:active {
             box-shadow: 0 2px 0 #8b6508, 0 2px 5px rgba(0,0,0,0.5);
        }

        .display-label {
            color: #d4af37;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .display-box {
            background: #000;
            color: #ff3333; /* LED Red */
            font-family: 'Courier New', monospace;
            font-weight: bold;
            font-size: 32px;
            padding: 10px 25px;
            border: 2px solid #444;
            border-radius: 8px;
            margin: 0 10px 20px 10px;
            display: inline-block;
            min-width: 80px;
            text-shadow: 0 0 8px #ff0000;
            box-shadow: inset 0 0 10px #000;
        }

        /* Overlay Messages (Jackpot/Game Over) */
        #message-overlay {
            position: absolute;
            top: 25%;
            width: 100%;
            text-align: center;
            pointer-events: none;
            font-size: 80px;
            font-weight: 900;
            color: #ffd700;
            text-shadow: 0 0 20px #ff0000, 0 0 40px #ff0000;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 20;
            transform: scale(0.8);
        }

        .pop-anim {
            animation: popIn 0.5s forwards, flashAnim 0.5s infinite alternate;
        }

        @keyframes popIn {
            to { transform: scale(1); }
        }

        @keyframes flashAnim {
            from { text-shadow: 0 0 20px #ff0000; }
            to { text-shadow: 0 0 50px #ffff00; filter: brightness(1.2); }
        }

        #loading {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #d4af37;
            font-size: 24px;
            z-index: 100;
        }
    </style>
</head>
<body>

    <div id="loading">Initializing 3D Engine...</div>
    <div id="message-overlay">JACKPOT!</div>

    <div id="ui-container">
        <div class="hud-panel">
            <div style="display:inline-block; vertical-align: top;">
                <div class="display-label">Credits</div>
                <div id="credits-display" class="display-box">0</div>
            </div>
            
            <div style="display:inline-block; vertical-align: top;">
                 <div class="display-label">Win</div>
                <div id="win-display" class="display-box">0</div>
            </div>

            <br>

            <button id="btn-coin" class="btn btn-coin" onclick="insertCoin()">Insert Coin</button>
            <button id="btn-spin" class="btn" onclick="spin()" disabled>SPIN</button>
        </div>
    </div>

    <script>
        // --- CONFIGURATION ---
        const SYMBOLS = ['7', 'BAR', 'CHERRY', 'BELL', 'DIAMOND', 'LEMON'];
        const SYMBOL_COLORS = {
            '7': '#ff0000',
            'BAR': '#ffffff',
            'CHERRY': '#ff00aa',
            'BELL': '#ffd700',
            'DIAMOND': '#00ffff',
            'LEMON': '#ccff00'
        };
        const REEL_RADIUS = 3;
        const SEGMENTS = SYMBOLS.length;
        const SEGMENT_ANGLE = (Math.PI * 2) / SEGMENTS;
        const COST_PER_SPIN = 10;
        
        let scene, camera, renderer;
        let reels = [];
        let running = false;
        let credits = 0;
        let coinMesh; 
        let coinSlotTarget;
        
        // --- 1. PROCEDURAL TEXTURE GENERATION ---
        function createSymbolTexture() {
            const canvas = document.createElement('canvas');
            // FIX: Swap dimensions to map symbols along the circumference (U-axis)
            canvas.width = 2048; 
            canvas.height = 512; 
            const ctx = canvas.getContext('2d');
            
            // 1a. Background (Metallic Strip - horizontal gradient now vertical on texture)
            // Since we are rotating everything, let's keep the gradient simple for the background
            const grad = ctx.createLinearGradient(0, 0, 0, 512); 
            grad.addColorStop(0, '#aaa');
            grad.addColorStop(0.2, '#fff');
            grad.addColorStop(0.5, '#eee');
            grad.addColorStop(0.8, '#fff');
            grad.addColorStop(1, '#aaa');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const segmentWidth = canvas.width / SEGMENTS;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            SYMBOLS.forEach((symbol, i) => {
                const cx = i * segmentWidth + (segmentWidth / 2);
                const cy = canvas.height / 2;
                
                // Divider Line (Vertical on canvas = Horizontal on Reel)
                ctx.strokeStyle = '#444';
                ctx.lineWidth = 6;
                ctx.beginPath();
                ctx.moveTo(i * segmentWidth, 0);
                ctx.lineTo(i * segmentWidth, canvas.height);
                ctx.stroke();

                // FIX: Rotate context to draw symbols sideways
                // This ensures that when mapped to the reel (which is rotated 90deg),
                // the symbols appear upright to the camera.
                ctx.save();
                ctx.translate(cx, cy);
                ctx.rotate(Math.PI / 2); // Rotate 90 degrees

                // Draw Symbol Graphics (Now drawing relative to center 0,0)
                ctx.fillStyle = SYMBOL_COLORS[symbol];
                
                // Glow Effect
                ctx.shadowColor = 'rgba(0,0,0,0.5)';
                ctx.shadowBlur = 15;
                ctx.shadowOffsetX = 5;
                ctx.shadowOffsetY = 5;

                if (symbol === '7') {
                    ctx.font = '900 280px "Arial Black", sans-serif';
                    ctx.fillStyle = '#ff0000';
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 5;
                    ctx.strokeText('7', 0, 0);
                    ctx.fillText('7', 0, 0);
                } 
                else if (symbol === 'BAR') {
                    // Black rounded rect with text
                    ctx.fillStyle = '#111';
                    // Coordinates adjusted for centered rotation
                    ctx.roundRect(-176, -70, 352, 140, 20);
                    ctx.fill();
                    
                    ctx.shadowColor = 'transparent';
                    ctx.fillStyle = '#fff';
                    ctx.font = '900 100px Arial';
                    ctx.fillText('BAR', 0, 5);
                } 
                else if (symbol === 'CHERRY') {
                    ctx.fillStyle = '#d00';
                    ctx.beginPath();
                    ctx.arc(-50, 30, 60, 0, Math.PI*2);
                    ctx.arc(50, 30, 60, 0, Math.PI*2);
                    ctx.fill();
                    
                    // Stems
                    ctx.strokeStyle = '#0a0';
                    ctx.lineWidth = 15;
                    ctx.beginPath();
                    ctx.moveTo(-50, 30);
                    ctx.quadraticCurveTo(0, -100, 80, -120);
                    ctx.moveTo(50, 30);
                    ctx.quadraticCurveTo(20, -100, 80, -120);
                    ctx.stroke();
                }
                else if (symbol === 'DIAMOND') {
                    ctx.fillStyle = '#0ff';
                    ctx.beginPath();
                    ctx.moveTo(0, -100);
                    ctx.lineTo(80, 0);
                    ctx.lineTo(0, 100);
                    ctx.lineTo(-80, 0);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                }
                else {
                    ctx.font = 'bold 180px Arial';
                    ctx.fillText(symbol, 0, 0);
                }
                
                ctx.restore(); // Restore context for next symbol
                ctx.shadowColor = 'transparent';
            });

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            // Adjust offset if needed to align the first symbol exactly center
            // By default, texture starts at U=0. 
            // We want the symbol center to be at the front.
            // Symbol 0 is at 0..segmentWidth. Center is segmentWidth/2.
            // This might need minor calibration visually, but usually 0 is fine.
            return texture;
        }

        function createCoinTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            
            // Gold Gradient
            const grad = ctx.createRadialGradient(64,64, 10, 64,64, 60);
            grad.addColorStop(0, '#fff');
            grad.addColorStop(0.2, '#ffd700');
            grad.addColorStop(1, '#b8860b');
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(64, 64, 60, 0, Math.PI*2);
            ctx.fill();
            
            // Detail Ring
            ctx.strokeStyle = '#b8860b';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(64, 64, 50, 0, Math.PI*2);
            ctx.stroke();

            // '$' Sign
            ctx.fillStyle = '#b8860b';
            ctx.font = 'bold 80px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('$', 64, 68);
            
            return new THREE.CanvasTexture(canvas);
        }

        // --- LEVER ANIMATION STATE ---
        let leverGroup = null;
        let leverAnimating = false;
        let leverPullProgress = 0;
        let leverReturning = false;
        
        // Lever animation constants
        const LEVER_PULL_SPEED = 0.08;
        const LEVER_RETURN_SPEED = 0.03;
        const LEVER_MAX_ANGLE = Math.PI * 0.4; // 72 degrees pull
        
        // Reference to machine group for animation (set during init)
        let machineGroupRef = null;

        // --- 2. 3D SCENE SETUP ---
        function init() {
            document.getElementById('loading').style.display = 'none';

            // Scene
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.015);

            // Camera
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 1, 28);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            document.body.appendChild(renderer.domElement);

            // --- ENHANCED LIGHTING ---
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            // Main spotlight from above
            const spotLight = new THREE.SpotLight(0xffffff, 1.5);
            spotLight.position.set(0, 20, 25);
            spotLight.angle = 0.5;
            spotLight.penumbra = 0.4;
            spotLight.castShadow = true;
            spotLight.shadow.mapSize.width = 2048;
            spotLight.shadow.mapSize.height = 2048;
            scene.add(spotLight);

            // Front fill light
            const frontLight = new THREE.DirectionalLight(0xffffff, 0.6);
            frontLight.position.set(0, 5, 20);
            scene.add(frontLight);

            // Neon accent lights (enhanced)
            const neonLeft = new THREE.PointLight(0xff00cc, 1.5, 25);
            neonLeft.position.set(-15, 0, 8);
            scene.add(neonLeft);

            const neonRight = new THREE.PointLight(0x00ffff, 1.5, 25);
            neonRight.position.set(15, 0, 8);
            scene.add(neonRight);

            // Top box backlight
            const topBackLight = new THREE.PointLight(0xffdd88, 2, 15);
            topBackLight.position.set(0, 10, -2);
            scene.add(topBackLight);

            // Belly glass backlight
            const bottomBackLight = new THREE.PointLight(0xffdd88, 2, 15);
            bottomBackLight.position.set(0, -10, -2);
            scene.add(bottomBackLight);

            // --- MATERIALS ---
            // Chrome/Silver metallic material for cabinet
            const chromeMat = new THREE.MeshStandardMaterial({
                color: 0xd4d4d4,
                metalness: 0.95,
                roughness: 0.1,
                envMapIntensity: 1.0
            });

            // Darker chrome for accents
            const darkChromeMat = new THREE.MeshStandardMaterial({
                color: 0x888888,
                metalness: 0.9,
                roughness: 0.2
            });

            // Red accent material
            const redMat = new THREE.MeshStandardMaterial({
                color: 0xcc0000,
                metalness: 0.7,
                roughness: 0.3,
                emissive: 0x330000,
                emissiveIntensity: 0.3
            });

            // Gold trim material
            const goldMat = new THREE.MeshStandardMaterial({
                color: 0xffd700,
                metalness: 1.0,
                roughness: 0.15,
                emissive: 0xaa6600,
                emissiveIntensity: 0.2
            });

            // Emissive material for backlit panels
            const emissivePanelMat = new THREE.MeshStandardMaterial({
                color: 0xffffee,
                emissive: 0xffdd88,
                emissiveIntensity: 0.8,
                roughness: 0.5
            });

            // Black plastic for button deck
            const blackPlasticMat = new THREE.MeshStandardMaterial({
                color: 0x111111,
                metalness: 0.1,
                roughness: 0.6
            });

            // --- BUILD MACHINE ---
            const machineGroup = new THREE.Group();
            scene.add(machineGroup);
            machineGroupRef = machineGroup; // Store reference for animation

            // ===== TOP BOX AREA =====
            // Main top box housing
            const topBoxGeo = new THREE.BoxGeometry(18, 6, 5);
            const topBox = new THREE.Mesh(topBoxGeo, chromeMat);
            topBox.position.set(0, 10, 0);
            topBox.castShadow = true;
            topBox.receiveShadow = true;
            machineGroup.add(topBox);

            // Top box front panel (backlit logo area)
            const topPanelGeo = new THREE.BoxGeometry(16, 4.5, 0.3);
            const topPanel = new THREE.Mesh(topPanelGeo, emissivePanelMat);
            topPanel.position.set(0, 10, 2.6);
            machineGroup.add(topPanel);

            // Gold trim around top panel
            const topTrimTop = new THREE.Mesh(new THREE.BoxGeometry(17, 0.4, 0.5), goldMat);
            topTrimTop.position.set(0, 12.5, 2.5);
            machineGroup.add(topTrimTop);

            const topTrimBottom = new THREE.Mesh(new THREE.BoxGeometry(17, 0.4, 0.5), goldMat);
            topTrimBottom.position.set(0, 7.5, 2.5);
            machineGroup.add(topTrimBottom);

            // Crown/topper decoration
            const crownGeo = new THREE.CylinderGeometry(1.5, 2, 1.5, 8);
            const crown = new THREE.Mesh(crownGeo, goldMat);
            crown.position.set(0, 14, 0);
            crown.rotation.y = Math.PI / 8;
            machineGroup.add(crown);

            // ===== REEL AREA (RECESSED) =====
            // Main reel housing - recessed back
            const reelHousingGeo = new THREE.BoxGeometry(18, 10, 6);
            const reelHousing = new THREE.Mesh(reelHousingGeo, chromeMat);
            reelHousing.position.set(0, 1.5, -1);
            reelHousing.castShadow = true;
            reelHousing.receiveShadow = true;
            machineGroup.add(reelHousing);

            // Inner reel cavity (darker, recessed area)
            const reelCavityGeo = new THREE.BoxGeometry(15, 8, 4);
            const reelCavityMat = new THREE.MeshStandardMaterial({
                color: 0x222222,
                metalness: 0.3,
                roughness: 0.8
            });
            const reelCavity = new THREE.Mesh(reelCavityGeo, reelCavityMat);
            reelCavity.position.set(0, 1.5, 0);
            machineGroup.add(reelCavity);

            // Chrome frame around reel window
            const frameThickness = 1.2;
            const frameTop = new THREE.Mesh(new THREE.BoxGeometry(17, frameThickness, 2), chromeMat);
            frameTop.position.set(0, 6, 2);
            machineGroup.add(frameTop);

            const frameBottom = new THREE.Mesh(new THREE.BoxGeometry(17, frameThickness, 2), chromeMat);
            frameBottom.position.set(0, -3, 2);
            machineGroup.add(frameBottom);

            const frameLeft = new THREE.Mesh(new THREE.BoxGeometry(frameThickness, 10.4, 2), chromeMat);
            frameLeft.position.set(-8.4, 1.5, 2);
            machineGroup.add(frameLeft);

            const frameRight = new THREE.Mesh(new THREE.BoxGeometry(frameThickness, 10.4, 2), chromeMat);
            frameRight.position.set(8.4, 1.5, 2);
            machineGroup.add(frameRight);

            // Gold accent strips
            const goldStripTop = new THREE.Mesh(new THREE.BoxGeometry(17.5, 0.3, 0.5), goldMat);
            goldStripTop.position.set(0, 6.8, 2.8);
            machineGroup.add(goldStripTop);

            const goldStripBottom = new THREE.Mesh(new THREE.BoxGeometry(17.5, 0.3, 0.5), goldMat);
            goldStripBottom.position.set(0, -3.8, 2.8);
            machineGroup.add(goldStripBottom);

            // Glass Cover for reels
            const glassGeo = new THREE.BoxGeometry(15, 8, 0.3);
            const glassMat = new THREE.MeshPhysicalMaterial({
                color: 0xffffff,
                metalness: 0.0,
                roughness: 0,
                transmission: 0.95,
                opacity: 0.15,
                transparent: true,
                reflectivity: 0.5,
                clearcoat: 1.0,
                ior: 1.5
            });
            const glass = new THREE.Mesh(glassGeo, glassMat);
            glass.position.set(0, 1.5, 3.2);
            machineGroup.add(glass);

            // Payline Indicator (red line)
            const lineGeo = new THREE.BoxGeometry(16, 0.1, 0.15);
            const lineMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const line = new THREE.Mesh(lineGeo, lineMat);
            line.position.set(0, 1.5, 3.4);
            machineGroup.add(line);

            // ===== BUTTON DECK (PROTRUDING SHELF) =====
            // Main button deck
            const deckGeo = new THREE.BoxGeometry(18, 3, 8);
            const deck = new THREE.Mesh(deckGeo, blackPlasticMat);
            deck.position.set(0, -5.5, 2);
            deck.castShadow = true;
            deck.receiveShadow = true;
            machineGroup.add(deck);

            // Deck top surface (slightly angled look with a separate piece)
            const deckTopGeo = new THREE.BoxGeometry(17, 0.3, 7);
            const deckTop = new THREE.Mesh(deckTopGeo, darkChromeMat);
            deckTop.position.set(0, -4.1, 2.5);
            machineGroup.add(deckTop);

            // Chrome trim on deck front
            const deckTrimGeo = new THREE.BoxGeometry(18.5, 0.5, 0.5);
            const deckTrim = new THREE.Mesh(deckTrimGeo, chromeMat);
            deckTrim.position.set(0, -4, 6.3);
            machineGroup.add(deckTrim);

            // Red accent strip on deck
            const redStripGeo = new THREE.BoxGeometry(16, 0.4, 0.3);
            const redStrip = new THREE.Mesh(redStripGeo, redMat);
            redStrip.position.set(0, -5, 6);
            machineGroup.add(redStrip);

            // ===== BELLY GLASS AREA =====
            // Main belly area
            const bellyGeo = new THREE.BoxGeometry(18, 5, 4);
            const belly = new THREE.Mesh(bellyGeo, chromeMat);
            belly.position.set(0, -9.5, 1);
            belly.castShadow = true;
            machineGroup.add(belly);

            // Backlit belly glass panel
            const bellyPanelGeo = new THREE.BoxGeometry(15, 3.5, 0.3);
            const bellyPanel = new THREE.Mesh(bellyPanelGeo, emissivePanelMat);
            bellyPanel.position.set(0, -9.5, 3.2);
            machineGroup.add(bellyPanel);

            // Gold trim around belly panel
            const bellyTrimTop = new THREE.Mesh(new THREE.BoxGeometry(16, 0.3, 0.4), goldMat);
            bellyTrimTop.position.set(0, -7.5, 3.3);
            machineGroup.add(bellyTrimTop);

            const bellyTrimBottom = new THREE.Mesh(new THREE.BoxGeometry(16, 0.3, 0.4), goldMat);
            bellyTrimBottom.position.set(0, -11.5, 3.3);
            machineGroup.add(bellyTrimBottom);

            // ===== SIDE PANELS =====
            // Left side panel
            const sidePanelGeo = new THREE.BoxGeometry(0.5, 22, 8);
            const leftPanel = new THREE.Mesh(sidePanelGeo, chromeMat);
            leftPanel.position.set(-9.25, 1, 0);
            leftPanel.castShadow = true;
            machineGroup.add(leftPanel);

            // Right side panel
            const rightPanel = new THREE.Mesh(sidePanelGeo, chromeMat);
            rightPanel.position.set(9.25, 1, 0);
            rightPanel.castShadow = true;
            machineGroup.add(rightPanel);

            // ===== LEVER (PULL HANDLE) =====
            leverGroup = new THREE.Group();
            leverGroup.position.set(10.5, 2, 3);
            machineGroup.add(leverGroup);

            // Lever base (mount)
            const leverBaseMat = new THREE.MeshStandardMaterial({
                color: 0x444444,
                metalness: 0.8,
                roughness: 0.3
            });
            const leverBaseGeo = new THREE.CylinderGeometry(0.8, 1, 1.5, 16);
            const leverBase = new THREE.Mesh(leverBaseGeo, leverBaseMat);
            leverBase.rotation.z = Math.PI / 2;
            leverGroup.add(leverBase);

            // Lever arm pivot point (at base)
            const leverArmGroup = new THREE.Group();
            leverArmGroup.position.set(0.5, 0, 0);
            leverGroup.add(leverArmGroup);
            leverGroup.userData.armGroup = leverArmGroup;

            // Lever arm (chrome shaft)
            const leverArmGeo = new THREE.CylinderGeometry(0.25, 0.3, 6, 12);
            const leverArm = new THREE.Mesh(leverArmGeo, chromeMat);
            leverArm.position.set(0, 3, 0);
            leverArmGroup.add(leverArm);

            // Lever handle (red ball)
            const handleMat = new THREE.MeshStandardMaterial({
                color: 0xff0000,
                metalness: 0.3,
                roughness: 0.4,
                emissive: 0x330000,
                emissiveIntensity: 0.2
            });
            const leverHandleGeo = new THREE.SphereGeometry(0.8, 16, 16);
            const leverHandle = new THREE.Mesh(leverHandleGeo, handleMat);
            leverHandle.position.set(0, 6.2, 0);
            leverHandle.castShadow = true;
            leverArmGroup.add(leverHandle);

            // Gold ring on lever
            const leverRingGeo = new THREE.TorusGeometry(0.5, 0.1, 8, 24);
            const leverRing = new THREE.Mesh(leverRingGeo, goldMat);
            leverRing.position.set(0, 5, 0);
            leverRing.rotation.x = Math.PI / 2;
            leverArmGroup.add(leverRing);

            // --- REELS ---
            const reelTexture = createSymbolTexture();
            const reelGeo = new THREE.CylinderGeometry(REEL_RADIUS, REEL_RADIUS, 4, 48, 1, true);
            // Rotate geometry so it spins on X axis (Horizontal)
            reelGeo.rotateZ(Math.PI / 2);
            
            const reelMat = new THREE.MeshStandardMaterial({ 
                map: reelTexture, 
                roughness: 0.3,
                metalness: 0.4
            });

            for (let i = 0; i < 3; i++) {
                const reel = new THREE.Mesh(reelGeo, reelMat);
                // Position reels: Left(-5), Center(0), Right(+5) - inside the recessed area
                reel.position.set((i - 1) * 5, 1.5, 1);
                reel.rotation.x = 0;
                
                reel.userData = { 
                    speed: 0, 
                    isStopping: false, 
                    finalAngle: 0 
                };
                
                reels.push(reel);
                machineGroup.add(reel);
            }

            // Reel dividers (between reels)
            const dividerGeo = new THREE.BoxGeometry(0.2, 8, 3);
            const dividerMat = new THREE.MeshStandardMaterial({
                color: 0x333333,
                metalness: 0.5,
                roughness: 0.4
            });
            
            const divider1 = new THREE.Mesh(dividerGeo, dividerMat);
            divider1.position.set(-2.5, 1.5, 1.5);
            machineGroup.add(divider1);
            
            const divider2 = new THREE.Mesh(dividerGeo, dividerMat);
            divider2.position.set(2.5, 1.5, 1.5);
            machineGroup.add(divider2);

            // --- COIN MECHANISM ---
            // Positioned on the button deck area, left side, to match typical slot machine layouts
            const slotFrameGeo = new THREE.BoxGeometry(1.2, 2.2, 0.4);
            const slotFrameMat = new THREE.MeshStandardMaterial({ 
                color: 0x666666, 
                metalness: 0.9,
                roughness: 0.2
            });
            const slotFrame = new THREE.Mesh(slotFrameGeo, slotFrameMat);
            slotFrame.position.set(-6, -5, 5.5); // On button deck, left of center
            machineGroup.add(slotFrame);

            const slotHoleGeo = new THREE.PlaneGeometry(0.25, 1.6);
            const slotHoleMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
            const slotHole = new THREE.Mesh(slotHoleGeo, slotHoleMat);
            slotHole.position.set(0, 0, 0.21);
            slotFrame.add(slotHole);

            coinSlotTarget = new THREE.Vector3();
            slotHole.getWorldPosition(coinSlotTarget);

            const coinGeo = new THREE.CylinderGeometry(0.6, 0.6, 0.1, 32);
            coinGeo.rotateX(Math.PI / 2);
            
            const coinMat = new THREE.MeshStandardMaterial({ 
                color: 0xffd700, 
                metalness: 1.0, 
                roughness: 0.2,
                map: createCoinTexture()
            });
            
            coinMesh = new THREE.Mesh(coinGeo, coinMat);
            coinMesh.visible = false;
            scene.add(coinMesh);

            // --- DECORATIVE LIGHTS (on sides) ---
            // Left side light strip
            for (let i = 0; i < 5; i++) {
                const lightGeo = new THREE.SphereGeometry(0.3, 8, 8);
                const baseColor = new THREE.Color(i % 2 === 0 ? 0xff0000 : 0xffff00);
                const lightMat = new THREE.MeshBasicMaterial({ 
                    color: baseColor.clone()
                });
                const decorLight = new THREE.Mesh(lightGeo, lightMat);
                decorLight.position.set(-9, -6 + i * 4, 4);
                decorLight.userData.isDecorLight = true;
                decorLight.userData.baseColor = baseColor; // Store as THREE.Color
                machineGroup.add(decorLight);
            }
            
            // Right side light strip
            for (let i = 0; i < 5; i++) {
                const lightGeo = new THREE.SphereGeometry(0.3, 8, 8);
                const baseColor = new THREE.Color(i % 2 === 0 ? 0xffff00 : 0xff0000);
                const lightMat = new THREE.MeshBasicMaterial({ 
                    color: baseColor.clone()
                });
                const decorLight = new THREE.Mesh(lightGeo, lightMat);
                decorLight.position.set(9, -6 + i * 4, 4);
                decorLight.userData.isDecorLight = true;
                decorLight.userData.baseColor = baseColor; // Store as THREE.Color
                machineGroup.add(decorLight);
            }

            animate();
        }

        // --- LEVER ANIMATION ---
        function animateLever() {
            if (!leverGroup || !leverGroup.userData.armGroup) return;
            
            const armGroup = leverGroup.userData.armGroup;
            
            if (leverAnimating) {
                if (!leverReturning) {
                    // Pulling down
                    leverPullProgress += LEVER_PULL_SPEED;
                    if (leverPullProgress >= 1) {
                        leverPullProgress = 1;
                        leverReturning = true;
                    }
                } else {
                    // Returning up
                    leverPullProgress -= LEVER_RETURN_SPEED;
                    if (leverPullProgress <= 0) {
                        leverPullProgress = 0;
                        leverAnimating = false;
                        leverReturning = false;
                    }
                }
                
                // Apply rotation (pull back = rotate towards player)
                armGroup.rotation.x = -leverPullProgress * LEVER_MAX_ANGLE;
            }
        }

        function triggerLeverPull() {
            if (!leverAnimating) {
                leverAnimating = true;
                leverReturning = false;
                leverPullProgress = 0;
            }
        }

        // --- ANIMATION & LOGIC ---
        
        function insertCoin() {
            const btn = document.getElementById('btn-coin');
            if (btn.disabled) return;
            btn.disabled = true;

            coinMesh.visible = true;
            const startPos = new THREE.Vector3(8, -10, 8); 
            const midPos = coinSlotTarget.clone();
            midPos.z += 0.5; 
            midPos.x += 0.2; 
            midPos.y += 0.2;
            const endPos = coinSlotTarget.clone();
            endPos.z -= 1.0; 
            
            coinMesh.position.copy(startPos);
            
            const startTime = Date.now();
            const duration = 1000; 

            function animateCoinFrame() {
                const now = Date.now();
                const progress = Math.min((now - startTime) / duration, 1);
                const ease = progress < 0.5 ? 2 * progress * progress : -1 + (4 - 2 * progress) * progress;

                if (progress < 0.6) {
                    const p = progress / 0.6;
                    coinMesh.position.lerpVectors(startPos, midPos, p);
                    coinMesh.rotation.set(0, 0, 0.2 * p); 
                } else {
                    const p = (progress - 0.6) / 0.4;
                    coinMesh.position.lerpVectors(midPos, endPos, p);
                    coinMesh.scale.setScalar(1 - (p * 0.2));
                }

                if (progress < 1) {
                    requestAnimationFrame(animateCoinFrame);
                } else {
                    coinMesh.visible = false;
                    coinMesh.scale.setScalar(1); 
                    credits += 10;
                    updateUI();
                    btn.disabled = false;
                }
            }
            animateCoinFrame();
        }

        function updateUI() {
            document.getElementById('credits-display').innerText = credits;
            const spinBtn = document.getElementById('btn-spin');
            if (credits >= COST_PER_SPIN && !running) {
                spinBtn.disabled = false;
            } else {
                spinBtn.disabled = true;
            }
        }

        function spin() {
            if (running || credits < COST_PER_SPIN) return;
            
            credits -= COST_PER_SPIN;
            updateUI();
            
            const overlay = document.getElementById('message-overlay');
            overlay.style.opacity = '0';
            overlay.classList.remove('pop-anim');
            document.getElementById('win-display').innerText = "0";

            running = true;
            document.getElementById('btn-spin').disabled = true;
            document.getElementById('btn-coin').disabled = true;

            // Trigger lever pull animation
            triggerLeverPull();

            reels.forEach((reel, i) => {
                reel.userData.speed = 0.4 + (Math.random() * 0.2);
                reel.userData.isStopping = false;
                setTimeout(() => {
                    prepareStopReel(i);
                }, 1500 + (i * 1000));
            });
        }

        function prepareStopReel(index) {
            const reel = reels[index];
            reel.userData.isStopping = true;
            
            const randomIndex = Math.floor(Math.random() * SEGMENTS);
            
            // Adjust calculation for horizontal wrapping texture (Mapping U to Angle)
            // U goes 0 to 1. Angle goes 0 to 2PI.
            // If we stop at angle X, we see symbol at U = X / 2PI.
            // Symbol i is at U = i / SEGMENTS.
            // So TargetAngle = i * SEGMENT_ANGLE.
            // HOWEVER, we need to account for rotation direction.
            // Reel rotates +X. Texture wraps +U.
            const targetSymbolAngle = randomIndex * SEGMENT_ANGLE;
            
            const currentRot = reel.rotation.x;
            const minSpins = Math.PI * 4; 
            
            let targetRot = targetSymbolAngle;
            while (targetRot < currentRot + minSpins) {
                targetRot += Math.PI * 2;
            }
            
            reel.userData.finalAngle = targetRot;
        }

        function checkWin() {
            running = false;
            document.getElementById('btn-coin').disabled = false;
            
            const results = reels.map(reel => {
                let angle = reel.rotation.x % (Math.PI * 2);
                if (angle < 0) angle += Math.PI * 2;
                
                // Index calculation:
                // If angle is 0, we are at U=0 (Symbol 0).
                // If angle increases, U increases.
                // We just need to ensure we round to nearest segment.
                let index = Math.round(angle / SEGMENT_ANGLE) % SEGMENTS;
                return SYMBOLS[index];
            });

            const [s1, s2, s3] = results;
            let winAmount = 0;
            let message = "";

            if (s1 === s2 && s2 === s3) {
                if (s1 === '7') winAmount = 500;
                else if (s1 === 'BAR') winAmount = 200;
                else winAmount = 100;
                message = "JACKPOT!";
            } else if (s1 === s2 || s2 === s3 || s1 === s3) {
                winAmount = 20;
                message = "WIN!";
            }

            if (winAmount > 0) {
                credits += winAmount;
                document.getElementById('win-display').innerText = winAmount;
                const overlay = document.getElementById('message-overlay');
                overlay.innerText = message + " +" + winAmount;
                overlay.style.opacity = '1';
                overlay.classList.add('pop-anim');
            } else {
                if(credits === 0) {
                    const overlay = document.getElementById('message-overlay');
                    overlay.innerText = "GAME OVER";
                    overlay.style.color = "red";
                    overlay.style.opacity = '1';
                }
            }
            updateUI();
        }

        function animate() {
            requestAnimationFrame(animate);

            // Animate lever
            animateLever();

            reels.forEach((reel, i) => {
                if (running) {
                    if (!reel.userData.isStopping) {
                        if (reel.userData.speed < 0.8) reel.userData.speed += 0.02;
                        reel.rotation.x += reel.userData.speed;
                    } else {
                        const remaining = reel.userData.finalAngle - reel.rotation.x;
                        if (remaining > 0.05) {
                            const step = remaining * 0.1;
                            reel.rotation.x += Math.max(step, 0.05);
                        } else {
                            reel.rotation.x = reel.userData.finalAngle;
                            if (i === 2 && running && 
                                reels[0].rotation.x === reels[0].userData.finalAngle && 
                                reels[1].rotation.x === reels[1].userData.finalAngle) {
                                setTimeout(checkWin, 100);
                            }
                        }
                    }
                }
            });

            const time = Date.now() * 0.002;
            
            // Animate neon accent lights with direct intensity assignment
            scene.children.forEach(obj => {
                if (obj.isPointLight) {
                    obj.intensity = 1.5 + Math.sin(time) * 0.5;
                }
            });

            // Animate decorative lights (chase effect) using stored reference
            if (machineGroupRef) {
                let lightIndex = 0;
                machineGroupRef.children.forEach(child => {
                    if (child.userData && child.userData.isDecorLight) {
                        const phase = (time + lightIndex * 0.5) % (Math.PI * 2);
                        const brightness = 0.5 + Math.sin(phase) * 0.5;
                        // Use stored THREE.Color directly without creating new object
                        child.material.color.copy(child.userData.baseColor).multiplyScalar(brightness);
                        lightIndex++;
                    }
                });
            }

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        init();

    </script>
</body>
</html>
