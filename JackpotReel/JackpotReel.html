<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pachinko Pinball Slot Machine</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * { box-sizing: border-box; }
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #1a0a2e 0%, #16213e 50%, #0f3460 100%);
            font-family: 'Courier New', Courier, monospace;
            user-select: none;
        }
        #ui-container {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            z-index: 10;
            pointer-events: none;
        }
        .hud-panel {
            background: linear-gradient(to bottom, #2b2b2b, #111);
            border: 3px solid #ff6b00;
            border-radius: 15px;
            padding: 20px;
            display: inline-block;
            pointer-events: auto;
            box-shadow: 0 0 15px rgba(255, 107, 0, 0.5), inset 0 0 20px rgba(0,0,0,0.8);
        }
        .btn {
            background: linear-gradient(180deg, #ff6b00, #cc5500);
            border: 2px solid #fff;
            color: white;
            padding: 15px 40px;
            font-size: 24px;
            font-weight: 900;
            border-radius: 50px;
            cursor: pointer;
            text-transform: uppercase;
            box-shadow: 0 6px 0 #993300, 0 10px 10px rgba(0,0,0,0.5);
            transition: all 0.1s;
            margin: 0 10px;
            text-shadow: 0 2px 2px rgba(0,0,0,0.5);
        }
        .btn:active { transform: translateY(4px); box-shadow: 0 2px 0 #993300; }
        .btn:disabled { background: #444; box-shadow: none; color: #888; border-color: #666; cursor: not-allowed; transform: translateY(4px); }
        .btn-coin { background: linear-gradient(180deg, #c0c0c0, #808080); box-shadow: 0 6px 0 #505050; color: #222; border-color: #ddd; }
        .btn-settings { background: linear-gradient(180deg, #4a90d9, #2a5a8a); box-shadow: 0 6px 0 #1a3a5a; font-size: 16px; padding: 10px 20px; }
        .display-label { color: #ff6b00; font-size: 12px; text-transform: uppercase; letter-spacing: 2px; margin-bottom: 5px; font-weight: bold; }
        .display-box { background: #000; color: #00ff00; font-family: 'Courier New', monospace; font-weight: bold; font-size: 32px; padding: 10px 25px; border: 2px solid #444; border-radius: 8px; margin: 0 10px 20px 10px; display: inline-block; min-width: 80px; text-shadow: 0 0 8px #00ff00; box-shadow: inset 0 0 10px #000; }
        #message-overlay { position: absolute; top: 25%; width: 100%; text-align: center; pointer-events: none; font-size: 80px; font-weight: 900; color: #ffd700; text-shadow: 0 0 20px #ff6b00, 0 0 40px #ff6b00; opacity: 0; transition: opacity 0.3s; z-index: 20; transform: scale(0.8); }
        .pop-anim { animation: popIn 0.5s forwards, flashAnim 0.5s infinite alternate; }
        @keyframes popIn { to { transform: scale(1); } }
        @keyframes flashAnim { from { text-shadow: 0 0 20px #ff6b00; } to { text-shadow: 0 0 50px #ffff00; filter: brightness(1.2); } }
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #ff6b00; font-size: 24px; z-index: 100; }
        /* Settings Modal */
        #settings-modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 100; justify-content: center; align-items: center; }
        #settings-modal.active { display: flex; }
        .settings-panel { background: linear-gradient(to bottom, #2a2a4a, #1a1a2a); border: 3px solid #ff6b00; border-radius: 15px; padding: 30px; max-width: 500px; width: 90%; max-height: 80vh; overflow-y: auto; color: #fff; }
        .settings-panel h2 { color: #ff6b00; margin-top: 0; text-align: center; }
        .setting-row { display: flex; justify-content: space-between; align-items: center; margin: 15px 0; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 8px; }
        .setting-row label { flex: 1; }
        .setting-row input { width: 80px; padding: 8px; border: 2px solid #ff6b00; border-radius: 5px; background: #111; color: #0f0; font-family: monospace; font-size: 16px; text-align: center; }
        .settings-buttons { display: flex; gap: 10px; margin-top: 20px; flex-wrap: wrap; justify-content: center; }
        .settings-buttons button { padding: 12px 20px; border: none; border-radius: 8px; cursor: pointer; font-weight: bold; font-size: 14px; }
        .btn-save { background: #28a745; color: white; }
        .btn-download { background: #17a2b8; color: white; }
        .btn-upload { background: #6c757d; color: white; }
        .btn-close { background: #dc3545; color: white; }
        #file-input { display: none; }
    </style>
</head>
<body>
    <div id="loading">Initializing Pachinko Pinball...</div>
    <div id="message-overlay">JACKPOT!</div>
    <div id="ui-container">
        <div class="hud-panel">
            <div style="display:inline-block; vertical-align: top;">
                <div class="display-label">Credits</div>
                <div id="credits-display" class="display-box">0</div>
            </div>
            <div style="display:inline-block; vertical-align: top;">
                <div class="display-label">Win</div>
                <div id="win-display" class="display-box">0</div>
            </div>
            <br>
            <button id="btn-coin" class="btn btn-coin" onclick="insertCoin()">Insert Ball</button>
            <button id="btn-spin" class="btn" onclick="spin()" disabled>LAUNCH</button>
            <button class="btn btn-settings" onclick="openSettings()">âš™ Settings</button>
        </div>
    </div>
    <!-- Settings Modal -->
    <div id="settings-modal">
        <div class="settings-panel">
            <h2>âš™ Win Ratio Settings</h2>
            <p style="text-align:center;color:#aaa;font-size:12px;">Configure payout multipliers for each symbol combination</p>
            <div id="settings-content"></div>
            <div class="settings-buttons">
                <button class="btn-save" onclick="saveSettings()">ðŸ’¾ Apply</button>
                <button class="btn-download" onclick="downloadSettings()">â¬‡ Download JSON</button>
                <button class="btn-upload" onclick="document.getElementById('file-input').click()">â¬† Upload JSON</button>
                <button class="btn-close" onclick="closeSettings()">âœ• Close</button>
            </div>
            <input type="file" id="file-input" accept=".json" onchange="uploadSettings(event)">
        </div>
    </div>

    <script>
        // Pachinko/Pinball themed symbols - all procedurally generated
        const SYMBOLS = ['BALL', 'FLIPPER', 'BUMPER', 'TARGET', 'BONUS', 'JACKPOT'];
        const SYMBOL_COLORS = {
            'BALL': '#c0c0c0',
            'FLIPPER': '#ff6b00',
            'BUMPER': '#ff00ff',
            'TARGET': '#00ff00',
            'BONUS': '#00ffff',
            'JACKPOT': '#ffd700'
        };
        
        // Default game settings (win ratios)
        let gameSettings = {
            costPerSpin: 10,
            coinValue: 10,
            payouts: {
                'JACKPOT': { three: 1000, two: 50 },
                'BONUS': { three: 500, two: 30 },
                'TARGET': { three: 200, two: 20 },
                'BUMPER': { three: 150, two: 15 },
                'FLIPPER': { three: 100, two: 10 },
                'BALL': { three: 50, two: 5 }
            },
            anyTwoMatch: 10
        };
        
        const REEL_RADIUS = 3;
        const SEGMENTS = SYMBOLS.length;
        const SEGMENT_ANGLE = (Math.PI * 2) / SEGMENTS;
        
        let scene, camera, renderer;
        let reels = [];
        let running = false;
        let credits = 0;
        let ballMesh;
        let ballSlotTarget;
        let leverGroup = null;
        let leverAnimating = false;
        let leverPullProgress = 0;
        let leverReturning = false;
        let machineGroupRef = null;
        
        const LEVER_PULL_SPEED = 0.08;
        const LEVER_RETURN_SPEED = 0.03;
        const LEVER_MAX_ANGLE = Math.PI * 0.4;

        // Procedural Pachinko Ball texture
        function createBallTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(64, 50, 10, 64, 64, 60);
            grad.addColorStop(0, '#ffffff');
            grad.addColorStop(0.3, '#c0c0c0');
            grad.addColorStop(0.7, '#808080');
            grad.addColorStop(1, '#404040');
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(64, 64, 60, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#606060';
            ctx.lineWidth = 3;
            ctx.stroke();
            return new THREE.CanvasTexture(canvas);
        }

        // Procedural reel symbol texture - Pachinko/Pinball themed
        function createSymbolTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 2048;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Metallic background
            const grad = ctx.createLinearGradient(0, 0, 0, 512);
            grad.addColorStop(0, '#1a1a2e');
            grad.addColorStop(0.2, '#2a2a4e');
            grad.addColorStop(0.5, '#3a3a5e');
            grad.addColorStop(0.8, '#2a2a4e');
            grad.addColorStop(1, '#1a1a2e');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const segmentWidth = canvas.width / SEGMENTS;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            SYMBOLS.forEach((symbol, i) => {
                const cx = i * segmentWidth + (segmentWidth / 2);
                const cy = canvas.height / 2;
                
                // Divider Line
                ctx.strokeStyle = '#ff6b00';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(i * segmentWidth, 0);
                ctx.lineTo(i * segmentWidth, canvas.height);
                ctx.stroke();

                ctx.save();
                ctx.translate(cx, cy);
                ctx.rotate(Math.PI / 2);
                
                ctx.shadowColor = SYMBOL_COLORS[symbol];
                ctx.shadowBlur = 20;
                ctx.fillStyle = SYMBOL_COLORS[symbol];

                if (symbol === 'BALL') {
                    // Pachinko ball
                    const ballGrad = ctx.createRadialGradient(0, -20, 10, 0, 0, 80);
                    ballGrad.addColorStop(0, '#ffffff');
                    ballGrad.addColorStop(0.5, '#c0c0c0');
                    ballGrad.addColorStop(1, '#606060');
                    ctx.fillStyle = ballGrad;
                    ctx.beginPath();
                    ctx.arc(0, 0, 80, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#404040';
                    ctx.lineWidth = 4;
                    ctx.stroke();
                }
                else if (symbol === 'FLIPPER') {
                    // Pinball flipper
                    ctx.fillStyle = '#ff6b00';
                    ctx.beginPath();
                    ctx.moveTo(-100, 30);
                    ctx.lineTo(100, 0);
                    ctx.lineTo(100, 20);
                    ctx.lineTo(-80, 50);
                    ctx.closePath();
                    ctx.fill();
                    ctx.strokeStyle = '#cc5500';
                    ctx.lineWidth = 4;
                    ctx.stroke();
                    // Pivot
                    ctx.fillStyle = '#333';
                    ctx.beginPath();
                    ctx.arc(-80, 40, 20, 0, Math.PI * 2);
                    ctx.fill();
                }
                else if (symbol === 'BUMPER') {
                    // Pinball bumper
                    const bumperGrad = ctx.createRadialGradient(0, 0, 10, 0, 0, 70);
                    bumperGrad.addColorStop(0, '#ff66ff');
                    bumperGrad.addColorStop(0.5, '#ff00ff');
                    bumperGrad.addColorStop(1, '#990099');
                    ctx.fillStyle = bumperGrad;
                    ctx.beginPath();
                    ctx.arc(0, 0, 70, 0, Math.PI * 2);
                    ctx.fill();
                    // Ring
                    ctx.strokeStyle = '#ffaaff';
                    ctx.lineWidth = 8;
                    ctx.beginPath();
                    ctx.arc(0, 0, 55, 0, Math.PI * 2);
                    ctx.stroke();
                    // Center
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(0, 0, 20, 0, Math.PI * 2);
                    ctx.fill();
                }
                else if (symbol === 'TARGET') {
                    // Target/hole
                    ctx.strokeStyle = '#00ff00';
                    ctx.lineWidth = 8;
                    for (let r = 70; r > 10; r -= 20) {
                        ctx.beginPath();
                        ctx.arc(0, 0, r, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    ctx.fillStyle = '#00ff00';
                    ctx.beginPath();
                    ctx.arc(0, 0, 15, 0, Math.PI * 2);
                    ctx.fill();
                }
                else if (symbol === 'BONUS') {
                    // Bonus star
                    ctx.fillStyle = '#00ffff';
                    ctx.beginPath();
                    for (let j = 0; j < 5; j++) {
                        const angle = (j * 4 * Math.PI / 5) - Math.PI / 2;
                        const x = Math.cos(angle) * 80;
                        const y = Math.sin(angle) * 80;
                        if (j === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.strokeStyle = '#008888';
                    ctx.lineWidth = 4;
                    ctx.stroke();
                }
                else if (symbol === 'JACKPOT') {
                    // Jackpot 7
                    ctx.font = '900 200px Arial Black';
                    ctx.fillStyle = '#ffd700';
                    ctx.strokeStyle = '#ff6b00';
                    ctx.lineWidth = 8;
                    ctx.strokeText('7', 0, 10);
                    ctx.fillText('7', 0, 10);
                }
                
                ctx.restore();
                ctx.shadowColor = 'transparent';
            });

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            return texture;
        }

        function init() {
            document.getElementById('loading').style.display = 'none';
            loadSettingsFromStorage();

            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x0a0a1a, 0.012);

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 1, 28);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            document.body.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);

            const spotLight = new THREE.SpotLight(0xffffff, 1.5);
            spotLight.position.set(0, 20, 25);
            spotLight.angle = 0.5;
            spotLight.penumbra = 0.4;
            spotLight.castShadow = true;
            scene.add(spotLight);

            const frontLight = new THREE.DirectionalLight(0xffffff, 0.6);
            frontLight.position.set(0, 5, 20);
            scene.add(frontLight);

            // Neon accent lights - orange/cyan theme
            const neonLeft = new THREE.PointLight(0xff6b00, 1.5, 25);
            neonLeft.position.set(-15, 0, 8);
            scene.add(neonLeft);

            const neonRight = new THREE.PointLight(0x00ffff, 1.5, 25);
            neonRight.position.set(15, 0, 8);
            scene.add(neonRight);

            // Materials - Pachinko themed
            const cabinetMat = new THREE.MeshStandardMaterial({ color: 0x1a1a2e, metalness: 0.3, roughness: 0.6 });
            const chromeTrimMat = new THREE.MeshStandardMaterial({ color: 0xc0c0c0, metalness: 1.0, roughness: 0.15 });
            const orangeAccentMat = new THREE.MeshStandardMaterial({ color: 0xff6b00, metalness: 0.4, roughness: 0.4, emissive: 0x331100, emissiveIntensity: 0.5 });
            const emissivePanelMat = new THREE.MeshStandardMaterial({ color: 0xffeedd, emissive: 0xff6633, emissiveIntensity: 0.4, roughness: 0.5 });
            const blackPlasticMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, metalness: 0.1, roughness: 0.6 });

            const machineGroup = new THREE.Group();
            scene.add(machineGroup);
            machineGroupRef = machineGroup;

            // Top box
            const topBox = new THREE.Mesh(new THREE.BoxGeometry(18, 6, 5), cabinetMat);
            topBox.position.set(0, 10, 0);
            topBox.castShadow = true;
            machineGroup.add(topBox);

            // Arch top
            const archGeo = new THREE.CylinderGeometry(9, 9, 5, 32, 1, false, 0, Math.PI);
            const arch = new THREE.Mesh(archGeo, cabinetMat);
            arch.rotation.x = Math.PI / 2;
            arch.rotation.z = Math.PI;
            arch.position.set(0, 13, 0);
            machineGroup.add(arch);

            // Top panel
            const topPanel = new THREE.Mesh(new THREE.BoxGeometry(16, 4.5, 0.3), emissivePanelMat);
            topPanel.position.set(0, 10, 2.6);
            machineGroup.add(topPanel);

            // Chrome trims
            machineGroup.add(Object.assign(new THREE.Mesh(new THREE.BoxGeometry(17, 0.4, 0.5), chromeTrimMat), { position: new THREE.Vector3(0, 12.5, 2.5) }));
            machineGroup.add(Object.assign(new THREE.Mesh(new THREE.BoxGeometry(17, 0.4, 0.5), chromeTrimMat), { position: new THREE.Vector3(0, 7.5, 2.5) }));

            // Reel housing
            const reelHousing = new THREE.Mesh(new THREE.BoxGeometry(18, 10, 6), cabinetMat);
            reelHousing.position.set(0, 1.5, -1);
            machineGroup.add(reelHousing);

            // Reel cavity
            const reelCavity = new THREE.Mesh(new THREE.BoxGeometry(15, 8, 4), new THREE.MeshStandardMaterial({ color: 0x0a0a1a, metalness: 0.2, roughness: 0.9 }));
            reelCavity.position.set(0, 1.5, 0);
            machineGroup.add(reelCavity);

            // Frame
            machineGroup.add(Object.assign(new THREE.Mesh(new THREE.BoxGeometry(17, 1.2, 2), chromeTrimMat), { position: new THREE.Vector3(0, 6, 2) }));
            machineGroup.add(Object.assign(new THREE.Mesh(new THREE.BoxGeometry(17, 1.2, 2), chromeTrimMat), { position: new THREE.Vector3(0, -3, 2) }));
            machineGroup.add(Object.assign(new THREE.Mesh(new THREE.BoxGeometry(1.2, 10.4, 2), chromeTrimMat), { position: new THREE.Vector3(-8.4, 1.5, 2) }));
            machineGroup.add(Object.assign(new THREE.Mesh(new THREE.BoxGeometry(1.2, 10.4, 2), chromeTrimMat), { position: new THREE.Vector3(8.4, 1.5, 2) }));

            // Orange accent strips
            machineGroup.add(Object.assign(new THREE.Mesh(new THREE.BoxGeometry(17.5, 0.3, 0.5), orangeAccentMat), { position: new THREE.Vector3(0, 6.8, 2.8) }));
            machineGroup.add(Object.assign(new THREE.Mesh(new THREE.BoxGeometry(17.5, 0.3, 0.5), orangeAccentMat), { position: new THREE.Vector3(0, -3.8, 2.8) }));

            // Glass
            const glassMat = new THREE.MeshPhysicalMaterial({ color: 0xffffff, metalness: 0.0, roughness: 0, transmission: 0.95, opacity: 0.15, transparent: true, clearcoat: 1.0, ior: 1.5 });
            machineGroup.add(Object.assign(new THREE.Mesh(new THREE.BoxGeometry(15, 8, 0.3), glassMat), { position: new THREE.Vector3(0, 1.5, 3.2) }));

            // Payline
            machineGroup.add(Object.assign(new THREE.Mesh(new THREE.BoxGeometry(16, 0.1, 0.15), new THREE.MeshBasicMaterial({ color: 0xff0000 })), { position: new THREE.Vector3(0, 1.5, 3.4) }));

            // Button deck
            const deck = new THREE.Mesh(new THREE.BoxGeometry(18, 3, 8), blackPlasticMat);
            deck.position.set(0, -5.5, 2);
            machineGroup.add(deck);

            // Belly
            const belly = new THREE.Mesh(new THREE.BoxGeometry(18, 5, 4), cabinetMat);
            belly.position.set(0, -9.5, 1);
            machineGroup.add(belly);

            const bellyPanel = new THREE.Mesh(new THREE.BoxGeometry(15, 3.5, 0.3), emissivePanelMat);
            bellyPanel.position.set(0, -9.5, 3.2);
            machineGroup.add(bellyPanel);

            // Side panels
            machineGroup.add(Object.assign(new THREE.Mesh(new THREE.BoxGeometry(0.5, 22, 8), cabinetMat), { position: new THREE.Vector3(-9.25, 1, 0) }));
            machineGroup.add(Object.assign(new THREE.Mesh(new THREE.BoxGeometry(0.5, 22, 8), cabinetMat), { position: new THREE.Vector3(9.25, 1, 0) }));

            // Lever
            leverGroup = new THREE.Group();
            leverGroup.position.set(10.5, 2, 3);
            machineGroup.add(leverGroup);

            const leverBase = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 1, 1.5, 16), chromeTrimMat);
            leverBase.rotation.z = Math.PI / 2;
            leverGroup.add(leverBase);

            const leverArmGroup = new THREE.Group();
            leverArmGroup.position.set(0.5, 0, 0);
            leverGroup.add(leverArmGroup);
            leverGroup.userData.armGroup = leverArmGroup;

            const leverArm = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.3, 6, 12), chromeTrimMat);
            leverArm.position.set(0, 3, 0);
            leverArmGroup.add(leverArm);

            const leverHandle = new THREE.Mesh(new THREE.SphereGeometry(0.8, 16, 16), orangeAccentMat);
            leverHandle.position.set(0, 6.2, 0);
            leverArmGroup.add(leverHandle);

            // Reels
            const reelTexture = createSymbolTexture();
            const reelGeo = new THREE.CylinderGeometry(REEL_RADIUS, REEL_RADIUS, 4, 48, 1, true);
            reelGeo.rotateZ(Math.PI / 2);
            const reelMat = new THREE.MeshStandardMaterial({ map: reelTexture, roughness: 0.3, metalness: 0.4 });

            for (let i = 0; i < 3; i++) {
                const reel = new THREE.Mesh(reelGeo, reelMat);
                reel.position.set((i - 1) * 5, 1.5, 1);
                reel.userData = { speed: 0, isStopping: false, finalAngle: 0 };
                reels.push(reel);
                machineGroup.add(reel);
            }

            // Reel dividers
            const dividerMat = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.5, roughness: 0.4 });
            machineGroup.add(Object.assign(new THREE.Mesh(new THREE.BoxGeometry(0.2, 8, 3), dividerMat), { position: new THREE.Vector3(-2.5, 1.5, 1.5) }));
            machineGroup.add(Object.assign(new THREE.Mesh(new THREE.BoxGeometry(0.2, 8, 3), dividerMat), { position: new THREE.Vector3(2.5, 1.5, 1.5) }));

            // Ball slot
            const slotFrame = new THREE.Mesh(new THREE.BoxGeometry(1.2, 2.2, 0.4), chromeTrimMat);
            slotFrame.position.set(-6, -5, 5.5);
            machineGroup.add(slotFrame);

            ballSlotTarget = new THREE.Vector3(-6, -5, 5.7);

            const ballGeo = new THREE.SphereGeometry(0.5, 32, 32);
            const ballMat = new THREE.MeshStandardMaterial({ color: 0xc0c0c0, metalness: 0.9, roughness: 0.1, map: createBallTexture() });
            ballMesh = new THREE.Mesh(ballGeo, ballMat);
            ballMesh.visible = false;
            scene.add(ballMesh);

            // Decorative lights
            for (let i = 0; i < 4; i++) {
                const baseColor = new THREE.Color(i % 2 === 0 ? 0xff6b00 : 0x00ffff);
                const light = new THREE.Mesh(new THREE.SphereGeometry(0.25, 8, 8), new THREE.MeshBasicMaterial({ color: baseColor.clone() }));
                light.position.set(-9, -4 + i * 4, 4);
                light.userData = { isDecorLight: true, baseColor: baseColor };
                machineGroup.add(light);
            }
            for (let i = 0; i < 4; i++) {
                const baseColor = new THREE.Color(i % 2 === 0 ? 0x00ffff : 0xff6b00);
                const light = new THREE.Mesh(new THREE.SphereGeometry(0.25, 8, 8), new THREE.MeshBasicMaterial({ color: baseColor.clone() }));
                light.position.set(9, -4 + i * 4, 4);
                light.userData = { isDecorLight: true, baseColor: baseColor };
                machineGroup.add(light);
            }

            animate();
        }

        function animateLever() {
            if (!leverGroup || !leverGroup.userData.armGroup) return;
            const armGroup = leverGroup.userData.armGroup;
            if (leverAnimating) {
                if (!leverReturning) {
                    leverPullProgress += LEVER_PULL_SPEED;
                    if (leverPullProgress >= 1) { leverPullProgress = 1; leverReturning = true; }
                } else {
                    leverPullProgress -= LEVER_RETURN_SPEED;
                    if (leverPullProgress <= 0) { leverPullProgress = 0; leverAnimating = false; leverReturning = false; }
                }
                armGroup.rotation.x = -leverPullProgress * LEVER_MAX_ANGLE;
            }
        }

        function triggerLeverPull() {
            if (!leverAnimating) { leverAnimating = true; leverReturning = false; leverPullProgress = 0; }
        }

        function insertCoin() {
            const btn = document.getElementById('btn-coin');
            if (btn.disabled) return;
            btn.disabled = true;

            ballMesh.visible = true;
            const startPos = new THREE.Vector3(8, -10, 8);
            const endPos = ballSlotTarget.clone();
            ballMesh.position.copy(startPos);

            const startTime = Date.now();
            const duration = 800;

            function animateBall() {
                const progress = Math.min((Date.now() - startTime) / duration, 1);
                ballMesh.position.lerpVectors(startPos, endPos, progress);
                ballMesh.rotation.x += 0.2;
                ballMesh.rotation.z += 0.1;
                if (progress < 1) {
                    requestAnimationFrame(animateBall);
                } else {
                    ballMesh.visible = false;
                    credits += gameSettings.coinValue;
                    updateUI();
                    btn.disabled = false;
                }
            }
            animateBall();
        }

        function updateUI() {
            document.getElementById('credits-display').innerText = credits;
            document.getElementById('btn-spin').disabled = !(credits >= gameSettings.costPerSpin && !running);
        }

        function spin() {
            if (running || credits < gameSettings.costPerSpin) return;
            credits -= gameSettings.costPerSpin;
            updateUI();

            const overlay = document.getElementById('message-overlay');
            overlay.style.opacity = '0';
            overlay.classList.remove('pop-anim');
            document.getElementById('win-display').innerText = '0';

            running = true;
            document.getElementById('btn-spin').disabled = true;
            document.getElementById('btn-coin').disabled = true;
            triggerLeverPull();

            reels.forEach((reel, i) => {
                reel.userData.speed = 0.4 + Math.random() * 0.2;
                reel.userData.isStopping = false;
                setTimeout(() => prepareStopReel(i), 1500 + i * 1000);
            });
        }

        function prepareStopReel(index) {
            const reel = reels[index];
            reel.userData.isStopping = true;
            const randomIndex = Math.floor(Math.random() * SEGMENTS);
            const targetAngle = randomIndex * SEGMENT_ANGLE;
            let targetRot = targetAngle;
            while (targetRot < reel.rotation.x + Math.PI * 4) targetRot += Math.PI * 2;
            reel.userData.finalAngle = targetRot;
        }

        function checkWin() {
            running = false;
            document.getElementById('btn-coin').disabled = false;

            const results = reels.map(reel => {
                let angle = reel.rotation.x % (Math.PI * 2);
                if (angle < 0) angle += Math.PI * 2;
                return SYMBOLS[Math.round(angle / SEGMENT_ANGLE) % SEGMENTS];
            });

            const [s1, s2, s3] = results;
            let winAmount = 0;
            let message = '';

            if (s1 === s2 && s2 === s3) {
                winAmount = gameSettings.payouts[s1]?.three || 100;
                message = s1 === 'JACKPOT' ? 'ðŸŽ° JACKPOT! ðŸŽ°' : 'âœ¨ BIG WIN! âœ¨';
            } else if (s1 === s2 || s2 === s3 || s1 === s3) {
                const matched = s1 === s2 ? s1 : (s2 === s3 ? s2 : s1);
                winAmount = gameSettings.payouts[matched]?.two || gameSettings.anyTwoMatch;
                message = 'ðŸŽ¯ WIN!';
            }

            if (winAmount > 0) {
                credits += winAmount;
                document.getElementById('win-display').innerText = winAmount;
                const overlay = document.getElementById('message-overlay');
                overlay.innerText = message + ' +' + winAmount;
                overlay.style.color = '#ffd700';
                overlay.style.opacity = '1';
                overlay.classList.add('pop-anim');
            } else if (credits === 0) {
                const overlay = document.getElementById('message-overlay');
                overlay.innerText = 'GAME OVER';
                overlay.style.color = 'red';
                overlay.style.opacity = '1';
            }
            updateUI();
        }

        function animate() {
            requestAnimationFrame(animate);
            animateLever();

            reels.forEach((reel, i) => {
                if (running) {
                    if (!reel.userData.isStopping) {
                        if (reel.userData.speed < 0.8) reel.userData.speed += 0.02;
                        reel.rotation.x += reel.userData.speed;
                    } else {
                        const remaining = reel.userData.finalAngle - reel.rotation.x;
                        if (remaining > 0.05) {
                            reel.rotation.x += Math.max(remaining * 0.1, 0.05);
                        } else {
                            reel.rotation.x = reel.userData.finalAngle;
                            if (i === 2 && running && reels[0].rotation.x === reels[0].userData.finalAngle && reels[1].rotation.x === reels[1].userData.finalAngle) {
                                setTimeout(checkWin, 100);
                            }
                        }
                    }
                }
            });

            const time = Date.now() * 0.002;
            scene.children.forEach(obj => { if (obj.isPointLight) obj.intensity = 1.5 + Math.sin(time) * 0.5; });
            if (machineGroupRef) {
                let idx = 0;
                machineGroupRef.children.forEach(child => {
                    if (child.userData?.isDecorLight) {
                        const brightness = 0.5 + Math.sin((time + idx * 0.5) % (Math.PI * 2)) * 0.5;
                        child.material.color.copy(child.userData.baseColor).multiplyScalar(brightness);
                        idx++;
                    }
                });
            }
            renderer.render(scene, camera);
        }

        // Settings functions
        function openSettings() {
            const modal = document.getElementById('settings-modal');
            modal.classList.add('active');
            renderSettingsContent();
        }

        function closeSettings() {
            document.getElementById('settings-modal').classList.remove('active');
        }

        function renderSettingsContent() {
            const container = document.getElementById('settings-content');
            let html = `
                <div class="setting-row"><label>Cost Per Spin</label><input type="number" id="set-cost" value="${gameSettings.costPerSpin}" min="1"></div>
                <div class="setting-row"><label>Ball Value (Credits)</label><input type="number" id="set-coin" value="${gameSettings.coinValue}" min="1"></div>
                <div class="setting-row"><label>Any Two Match Payout</label><input type="number" id="set-any2" value="${gameSettings.anyTwoMatch}" min="0"></div>
                <h3 style="color:#ff6b00;margin-top:20px;">Symbol Payouts</h3>
            `;
            SYMBOLS.forEach(sym => {
                const p = gameSettings.payouts[sym] || { three: 100, two: 10 };
                html += `
                    <div style="margin:10px 0;padding:10px;background:rgba(255,107,0,0.1);border-radius:8px;">
                        <strong style="color:${SYMBOL_COLORS[sym]}">${sym}</strong>
                        <div class="setting-row"><label>Three Match</label><input type="number" id="set-${sym}-3" value="${p.three}" min="0"></div>
                        <div class="setting-row"><label>Two Match</label><input type="number" id="set-${sym}-2" value="${p.two}" min="0"></div>
                    </div>
                `;
            });
            container.innerHTML = html;
        }

        function saveSettings() {
            gameSettings.costPerSpin = parseInt(document.getElementById('set-cost').value) || 10;
            gameSettings.coinValue = parseInt(document.getElementById('set-coin').value) || 10;
            gameSettings.anyTwoMatch = parseInt(document.getElementById('set-any2').value) || 10;
            SYMBOLS.forEach(sym => {
                gameSettings.payouts[sym] = {
                    three: parseInt(document.getElementById(`set-${sym}-3`).value) || 100,
                    two: parseInt(document.getElementById(`set-${sym}-2`).value) || 10
                };
            });
            localStorage.setItem('pachinkoSlotSettings', JSON.stringify(gameSettings));
            updateUI();
            alert('Settings saved!');
        }

        function downloadSettings() {
            saveSettings();
            const blob = new Blob([JSON.stringify(gameSettings, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'pachinko-slot-settings.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        function uploadSettings(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const loaded = JSON.parse(e.target.result);
                    gameSettings = { ...gameSettings, ...loaded };
                    localStorage.setItem('pachinkoSlotSettings', JSON.stringify(gameSettings));
                    renderSettingsContent();
                    updateUI();
                    alert('Settings loaded successfully!');
                } catch (err) {
                    alert('Error loading settings: ' + err.message);
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        function loadSettingsFromStorage() {
            const saved = localStorage.getItem('pachinkoSlotSettings');
            if (saved) {
                try { gameSettings = { ...gameSettings, ...JSON.parse(saved) }; } catch (e) {}
            }
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        init();
    </script>
</body>
</html>
